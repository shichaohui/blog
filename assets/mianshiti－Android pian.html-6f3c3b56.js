import{_ as c,p as t,q as s,s as e,R as o,t as n,Y as d,n as i}from"./framework-a25df3d5.js";const r={},l={href:"https://shichaohui.github.io/",target:"_blank",rel:"noopener noreferrer"},p={href:"https://shichaohui.github.io/",target:"_blank",rel:"noopener noreferrer"},u=e("p",null,[o("最近得空，就去一些招聘网站做了些面试题，为方便大家共同学习，"),e("code",null,"Android"),o(" 相关的就在这篇博客里记录一下，以后有空会持续更新，大家有更好的答案也可以留言告诉我。")],-1),h={href:"http://blog.csdn.net/u014165119/article/details/49908451",target:"_blank",rel:"noopener noreferrer"},_={href:"http://blog.csdn.net/u014165119/article/details/49910119",target:"_blank",rel:"noopener noreferrer"},v=d(`<h3 id="_1-android-中五种数据存储方式分别是什么-详细说下他们的特点" tabindex="-1"><a class="header-anchor" href="#_1-android-中五种数据存储方式分别是什么-详细说下他们的特点" aria-hidden="true">#</a> 1. Android 中五种数据存储方式分别是什么？详细说下他们的特点？</h3><ul><li>使用 <code>SharedPreferences</code> 存储数</li></ul><p><code>SharedPreferences</code> 是 <code>Android</code> 平台上一个轻量级的存储类，它的本质是基于 <code>XML</code> 文件存储 <code>key-value</code> 键值对数据，通常用来存储一些简单的配置信息，它提供了基础类型（如 <code>int</code>，<code>long</code>）和 <code>String</code> 的保存，<code>SharedPreferences</code> 对象本身只能获取数据而不支持存储和修改，存储修改是通过 <code>Editor</code> 对象实现。</p><ul><li>文件存储数据</li></ul><p>关于文件存储，<code>Activity</code> 提供了 <code>openFileOutput()</code> 方法可以用于把数据输出到文件中，具体的实现过程与在 <code>J2SE</code> 环境中保存数据到文件中是一样的。</p><p>文件可用来存放大量数据，如文本、图片、音频等。</p><p>使用文件存储数据可以将数据保存在 SD 卡，以减少手机内存的占用，访问 SD 卡中需要以下权限：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 在SDCard中创建与删除文件权限 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>android.permission.MOUNT_UNMOUNT_FILESYSTEMS<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 往SDCard写入数据权限 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>android.permission.WRITE_EXTERNAL_STORAGE<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>SQLite 数据库存储数据</li></ul><p><code>SQLite</code> 是轻量级嵌入式数据库引擎，它支持 <code>SQL</code> 语言，并且只利用很少的内存就有很好的性能。此外它还是开源的，任何人都可以使用它。<code>SQLite</code> 通过利用虚拟机和虚拟数据库引擎（<code>VDBE</code>），使调试、修改和扩展 <code>SQLite</code> 的内核变得更加方便。</p><p>Android提供了一个名为 <code>SQLiteDatabase</code> 的类，该类封装了一些操作数据库的 <code>API</code>，使用该类可以完成对数据进行添加（<code>Create</code>）、查询（<code>Retrieve</code>）、更新（<code>Update</code>）和删除（<code>Delete</code>）操作（这些操作简称为 <code>CRUD</code>）。</p><ul><li>使用 <code>ContentProvider</code> 存储数据</li></ul><p><code>ContentProvider</code> 是所有应用程序之间数据存储和检索的一个桥梁，它的作用就是使得各个应用程序之间实现数据共享。<code>Android</code> 为常见的一些数据提供了 <code>ContentProvider</code>（包括音频、视频、图片和通讯录）。</p><p>每个 <code>Content Providers</code> 都会对外提供一个公共的 <code>URI</code>（包装成 <code>Uri</code> 对象），如果应用程序有数据需要共享时，就需要使用 <code>Content Providers</code> 为这些数据定义一个 <code>URI</code>，然后其他的应用程序就可以通过 <code>Content Providers</code>传入这个 <code>URI</code> 来对数据进行操作。<code>URI</code> 由 3 个部分组成: <code>content://</code>、数据的路径、标识 ID（可选）。</p><ul><li>网络存储数据</li></ul><p>前面介绍的几种存储都是将数据存储在本地设备上，除此之外，还可以通过网络来实现数据的存储和获取，我们可以调用 <code>WebService</code> 返回的数据或是解析 <code>HTTP</code> 协议实现网络数据交互。</p><p>访问网络需要添加以下权限：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>android.permission.INTERNET<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_2-sharedpreferences-与-sqlite-数据库的区别" tabindex="-1"><a class="header-anchor" href="#_2-sharedpreferences-与-sqlite-数据库的区别" aria-hidden="true">#</a> 2. SharedPreferences 与 SQLite 数据库的区别</h3><p>见题1</p><h3 id="_3-什么是anr如何避免它" tabindex="-1"><a class="header-anchor" href="#_3-什么是anr如何避免它" aria-hidden="true">#</a> 3. 什么是ANR如何避免它</h3><p><code>ANR</code>（Application Not Responding），意思是应用没有响应。\`</p><p><code>Android</code> 通常会在如下情况报出 <code>ANR</code> 错误：</p><ul><li>主线程（事件处理线程 / UI 线程） 在 5 秒内没有响应输入事件</li><li><code>BroadcastReceiver</code> 没有在 10 秒内完成返回</li></ul><p>因此，为了避免 <code>ANR</code>，不要在主线程执行耗时操作，如访问网络（Android4.0以上版本在主线程访问网络会直接报出异常 <code>NetworkOnMainThreadException</code>）、数据库存储等，这些耗时的操作可以新开一个线程去执行，如果要在新线程中处理 UI，可以使用 <code>Handler</code>。</p><h3 id="_4-android-中的动画有哪几类-它们的特点和区别是什么" tabindex="-1"><a class="header-anchor" href="#_4-android-中的动画有哪几类-它们的特点和区别是什么" aria-hidden="true">#</a> 4. android 中的动画有哪几类，它们的特点和区别是什么？</h3><ul><li>补间动画</li></ul><p>补间动画有四种：位移动画（<code>TranslateAnimation</code>）、旋转动画（<code>RotateAnimation</code>）、透明度渐变动画（<code>AlphaAnimation</code>）、缩放动画（<code>ScaleAnimation</code>）。</p><p>使用补间动画时只需要指定动画的开始状态和结束状态，<code>Android</code> 会自动计算中间的动画效果并完成动画。</p><ul><li>逐帧动画</li></ul><p>逐帧动画使用多张图片作为一个动画的帧，并通过一定顺序播放这些帧以形成动画。</p><ul><li>属性动画</li></ul><p>属性动画是 Android3.0 新增的动画，目的是弥补补间动画的不足，并提高动画的扩展性，这里有个不错的系列博客，我就不多扯了。</p>`,33),k={href:"http://blog.csdn.net/guolin_blog/article/details/43536355",target:"_blank",rel:"noopener noreferrer"},m={href:"http://blog.csdn.net/guolin_blog/article/details/43816093",target:"_blank",rel:"noopener noreferrer"},A={href:"http://blog.csdn.net/guolin_blog/article/details/44171115",target:"_blank",rel:"noopener noreferrer"},g=d('<h3 id="_5-res-raw-与-assets-目录的区别" tabindex="-1"><a class="header-anchor" href="#_5-res-raw-与-assets-目录的区别" aria-hidden="true">#</a> 5. res/raw 与 assets 目录的区别</h3><p>相同点：两者目录下的文件在打包后会原封不动的保存在 apk 包中，不会被编译成二进制。</p><p>不同点：</p><ul><li><code>res/raw</code> 中的文件会被映射到 <code>R.java</code> 文件中，访问的时候直接使用资源 ID 即 <code>R.id.filename</code>；<code>assets</code> 文件夹下的文件不会被映射到 <code>R.java</code> 中，访问的时候需要 <code>AssetManager</code> 类。</li><li><code>res/raw</code> 不可以有目录结构，而 <code>assets</code> 则可以有目录结构，也就是 <code>assets</code> 目录下可以再建立文件夹。</li></ul><h3 id="_6-简述-handler-机制原理" tabindex="-1"><a class="header-anchor" href="#_6-简述-handler-机制原理" aria-hidden="true">#</a> 6. 简述 Handler 机制原理</h3><p><code>Handler</code> 是一个消息分发对象，而消息分发，有赖于消息循环（<code>Looper</code>），每一个线程中最多有一个 <code>Looper</code>（子线程如果没有创建 <code>Looper</code>，将会使用主线程的 <code>Looper</code>，主线程在创建时自动创建一个 <code>Looper</code>），<code>Looper</code> 阻塞线程，等待消息构成循环，有了消息，分配到对应的 <code>Handler</code>，让他进一步分发处理。</p><h3 id="_7-说说-view-的刷新机制" tabindex="-1"><a class="header-anchor" href="#_7-说说-view-的刷新机制" aria-hidden="true">#</a> 7. 说说 View 的刷新机制</h3><p>在 <code>Android</code> 的布局体系中，父 <code>View</code> 负责刷新、布局显示子 <code>View</code>；而当子 <code>View</code> 需要刷新时，则是通知父 <code>View</code> 来完成。</p><h3 id="_8-activity-和-task-的启动模式有哪些-每种含义是什么" tabindex="-1"><a class="header-anchor" href="#_8-activity-和-task-的启动模式有哪些-每种含义是什么" aria-hidden="true">#</a> 8. Activity 和 Task 的启动模式有哪些?每种含义是什么?</h3><ul><li><code>standard</code>：默认的启动模式，每次激活 <code>Activity</code> 时（<code>startActivity</code>），都创建 <code>Activity</code> 实例，并放入任务栈。</li><li><code>singleTop</code>：如果某个 <code>Activity</code> 自己激活自己，即任务栈栈顶就是该 <code>Activity</code>，则不需要创建，其余情况都要创建 <code>Activity</code> 实例；</li><li><code>singleInstance</code>：如果应用 1 的任务栈中创建了 <code>MainActivity</code> 实例，如果应用 2 也要激活 <code>MainActivity</code>，则不需要创建，两应用共享该 <code>Activity</code> 实例；</li><li><code>singleTask</code>：如果要激活的那个 <code>Activity</code> 在任务栈中存在该实例，则不需要创建，只需要把此 <code>Activity</code> 放入栈顶，并把该 <code>Activity</code> 以上的 <code>Activity</code> 实例都 <code>pop</code>；</li></ul>',10),b={href:"http://blog.csdn.net/zapzqc/article/details/8493481",target:"_blank",rel:"noopener noreferrer"},f=d("<p><code>SingTask</code> 的可以用来退出整个应用：将主 <code>Activity</code> 设为 <code>SingTask</code> 模式，然后在要退出的 <code>Activity</code> 中转到主 <code>Activity</code>，然后重写主 <code>Activity</code> 的 <code>onNewIntent</code> 函数，并在函数中加上一句 <code>finish</code> 即可。</p>",1);function S(y,x){const a=i("ExternalLinkIcon");return t(),s("div",null,[e("blockquote",null,[e("p",null,[o("转载请注明出处，"),e("a",l,[o("点击此处"),n(a)]),o("可了解 "),e("a",p,[o("StoneHui"),n(a)]),o(" 更多信息")])]),u,e("p",null,[e("a",h,[o("面试题－Java算法篇 传送门"),n(a)])]),e("p",null,[e("a",_,[o("面试题－Java API篇 传送门"),n(a)])]),v,e("p",null,[e("a",k,[o("Android属性动画完全解析(上)，初识属性动画的基本用法"),n(a)])]),e("p",null,[e("a",m,[o("Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法"),n(a)])]),e("p",null,[e("a",A,[o("Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法"),n(a)])]),g,e("p",null,[o("详见："),e("a",b,[o("Activity的四种启动模式"),n(a)])]),f])}const I=c(r,[["render",S],["__file","mianshiti－Android pian.html.vue"]]);export{I as default};
