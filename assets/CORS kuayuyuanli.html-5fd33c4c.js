import{_ as t,p as i,q as r,s as e,R as o,t as c,Y as d,n as a}from"./framework-a25df3d5.js";const n={},s={href:"https://shichaohui.github.io/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://blog.csdn.net/u014165119/article/details/111355519",target:"_blank",rel:"noopener noreferrer"},u=e("h2",{id:"什么是-cors",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#什么是-cors","aria-hidden":"true"},"#"),o(" 什么是 CORS？")],-1),p=e("blockquote",null,[e("p",null,[e("code",null,"CORS"),o(" 全称 "),e("code",null,"Cross-Origin Resource Sharing"),o("，即跨域资源共享。")])],-1),_=e("code",null,"CORS",-1),g={href:"https://developer.mozilla.org/en-US/docs/Glossary/Header",target:"_blank",rel:"noopener noreferrer"},f=e("code",null,"CORS",-1),C=d('<h2 id="cors-验证机制" tabindex="-1"><a class="header-anchor" href="#cors-验证机制" aria-hidden="true">#</a> CORS 验证机制</h2><p><code>CORS</code> 的验证机制分两种模式：简单请求和预检请求。</p><h3 id="简单请求" tabindex="-1"><a class="header-anchor" href="#简单请求" aria-hidden="true">#</a> 简单请求</h3><p>简单请求模式下浏览器直接发送请求，并在请求头中携带 <code>Origin</code>。 服务器端接到请求后，会根据自己的跨域规则，通过响应头 <code>Access-Control-Allow-Origin</code> 来返回验证结果。</p><p>请求满足以下所有条件即为简单请求：</p><ol><li>请求方法</li></ol><ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul><ol start="2"><li><code>Content-Type</code> 字段值</li></ol><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul>',9),A={start:"3"},m=e("code",null,"Header",-1),x={href:"https://fetch.spec.whatwg.org",target:"_blank",rel:"noopener noreferrer"},H=e("code",null,"CORS",-1),O=d('<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul><h3 id="预检请求" tabindex="-1"><a class="header-anchor" href="#预检请求" aria-hidden="true">#</a> 预检请求</h3><p>需要预检的请求必须首先使用 <code>OPTIONS</code> 方法发起一个预检请求到服务器，服务器基于预检请求的信息来判断是否接受接下来的实际请求。</p><p><strong>预检请求 <code>Header</code>：</strong></p><ul><li><code>Access-Control-Request-Method</code></li></ul><p>指明实际请求所使用的 <code>HTTP</code> 方法。</p><ul><li><code>Access-Control-Request-Headers</code></li></ul><p>指明实际请求所携带的字段。</p><p><strong>预检响应 <code>Header</code>：</strong></p><ul><li><code>Access-Control-Allow-Origin</code></li></ul><p>指明允许访问的域。</p><ul><li><code>Access-Control-Allow-Methods</code></li></ul><p>指明允许的 <code>HTTP</code> 请求方法。</p><ul><li><code>Access-Control-Allow-Headers</code></li></ul><p>指明允许携带的字段。</p><ul><li><code>Access-Control-Max-Age</code></li></ul><p>指明该响应的有效时间，在有效时间内，浏览器无须为同一请求再次发起预检请求。</p><p>浏览器检查预检响应信息，如果预检通过就发送实际请求。</p><p>使用预检请求可以避免跨域请求对服务器的数据产生未预期的影响。</p><h2 id="http-header" tabindex="-1"><a class="header-anchor" href="#http-header" aria-hidden="true">#</a> HTTP Header</h2><h3 id="请求-header" tabindex="-1"><a class="header-anchor" href="#请求-header" aria-hidden="true">#</a> 请求 Header</h3><ul><li><code>Origin: &lt;origin&gt;</code></li></ul><p>指明请求所在域。</p><ul><li><code>Access-Control-Request-Method: &lt;method&gt;</code></li></ul><p>指明请求所使用的 <code>HTTP</code> 方法。</p><ul><li><code>Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code></li></ul><p>指明请求所携带的字段。</p><h3 id="响应-header" tabindex="-1"><a class="header-anchor" href="#响应-header" aria-hidden="true">#</a> 响应 Header</h3><ul><li><code>Access-Control-Allow-Origin: &lt;origin&gt; | *</code></li></ul><p><code>origin</code> 值指定了允许访问该资源的域，<code>*</code> 表示允许任意域的请求。</p><ul><li><code>Access-Control-Expose-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code></li><li></li></ul><p>指明允许浏览器访问的字段。</p><ul><li><code>Access-Control-Max-Age: &lt;delta-seconds&gt;</code></li></ul><p>指明该响应的有效时间，在有效时间内，浏览器无须为同一请求再次发起预检请求。</p>',34);function R(T,b){const l=a("ExternalLinkIcon");return i(),r("div",null,[e("blockquote",null,[e("p",null,[e("small",null,[o("转载请注明出处，"),e("a",s,[o("点击此处"),c(l)]),o(" 查看更多精彩内容")])])]),e("p",null,[o("前置知识点： "),e("a",h,[o("同源策略 & 跨域"),c(l)])]),u,p,e("p",null,[_,o(" 是一种基于 "),e("a",g,[o("HTTP Header"),c(l)]),o(" 的机制，该机制通过允许服务器标示除了它自己以外的其它域。服务器端配合浏览器实现 "),f,o(" 机制，可以突破浏览器对跨域资源访问的限制，实现跨域资源请求。")]),C,e("ol",A,[e("li",null,[o("手动设置的 "),m,o(" 字段只能为自定义字段和 "),e("a",x,[o("Fetch"),c(l)]),o(" 规范定义的 "),H,o(" 安全字段。")])]),O])}const k=t(n,[["render",R],["__file","CORS kuayuyuanli.html.vue"]]);export{k as default};
