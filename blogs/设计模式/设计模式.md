---
title: 设计模式
date: 2019-10-16 11:14
tags:
 - 设计模式
categories:
 - 设计模式
---

> <small>转载请注明出处，[点击此处](https://shichaohui.github.io/) 查看更多精彩内容</small>

## 一、简介

设计模式代表了软件开发的最佳实践，是软件开发人员在软件开发过程中面临的一般问题的解决方案，是一套反复使用的、多人知晓的、经过分类编目的代码设计经验的总结。

使用设计模式的目的是重用代码、让代码更易理解、保证代码的可靠性和可维护性。

学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。

## 二、设计原则

### 开闭原则

对扩展开发，对修改关闭。

在对程序进行扩展的时候不能修改原有代码，实现热插拔的效果。要想实现这样的效果，需要使用接口和抽象类。

**优点：** 提高代码的复用性和可维护性。

### 单一职责原则

单一职责原则规定一个类或者函数应该只有一个引起它发生变化的原因，否则类或者函数应该被拆分。

**优点：** 降低系统的复杂度，提高可读性和可维护性，降低变更带来的风险。

### 接口隔离原则

客户端不应该被迫依赖它不需要的函数，一个类对另一个类的依赖应该建立在最小的接口上，而不要试图建立一个功能复杂的庞大的接口供所有依赖它的类去调用。

**优点：** 提高类的内聚性，降低类之间的耦合。减少冗余代码。提高系统的灵活性和可维护性。

### 依赖倒置原则

细节应该依赖抽象，抽象不应该依赖细节。高层模块应该依赖低层模块，低层模块不应该依赖高层模块。

其核心思想就是针对接口编程。

**优点：** 降低耦合，提高代码的复用性，减少并行开发的风险。

### 里氏代换原则

继承类必须保证基类所拥有的特性在子类中依然成立，使得所有基类出现的地方都可以使用子类替换。

里氏代换原则是继承复用的基础，反应的是基类与子类的关系。

里氏代换原则是对开闭原则的补充，使用开闭原则的关闭步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是实现抽象化的具体步骤的规范。

**优点：** 克服了继承中重写父类导致的复用性变差的问题，降低代码出错的可能性。

### 迪米特法则（最少知识原则）

一个类应该尽可能少的与其他类发生相互作用。

从依赖者角度来说，只依赖应该依赖的对象。

从被依赖者的角度来说，只暴露应该暴露的方法。

**优点：** 降低耦合，提高模块的相互独立性。

### 合成复用原则

合成复用原则要求在软件复用时，尽量使用合成或聚合等关联关系来实现，其次才考虑使用继承关系实现。

## 三、分类

根据设计模式的参考书 **Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）** 中所提到的，总共有 23 种设计模式。这些模式可以分为三类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。

### 创建型模式

创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是直接使用 new 创建对象。这使得系统在指定条件下判断需要创建的对象时更加灵活。

* [工厂模式（Factory Pattern）](https://blog.csdn.net/u014165119/article/details/102590569)
* 抽象工厂模式（Abstract Factory Pattern）
* 建造者模式（Builder Pattern）
* 单例模式（Singleton Pattern）
* 原型模式（Prototype Pattern）

### 结构型模式

结构型模式关注类与对象之间的组合。

* 适配器模式（Adapter Pattern）
* 桥接模式（Bridge Pattern）
* 过滤器模式（Filter、Criteria Pattern）
* 组合模式（Composite Pattern）
* 装饰器模式（Decorate Pattern）
* 代理模式（Proxy Pattern）
* 外观模式（Facade Pattern）
* 享元模式（Flyweight Pattern）

### 行为型模式

行为型模式关注的是对象之间的通信。

* 责任链模式（Chain of Responsibility Pattern）
* 命令模式（Common Pattern）
* 解释器模式（Interpreter Pattern）
* 迭代器模式（Iterator Pattern）
* 中介者模式（Mediator Pattern）
* 备忘录模式（Memento Pattern）
* 观察者模式（Observer Pattern）
* 状态模式（State Pattern）
* 空对象模式（Null Object Pattern）
* 策略模式（Strategy Pattern）
* 模板模式（Template Pattern）
* 访问者模式（Visitor Pattern）